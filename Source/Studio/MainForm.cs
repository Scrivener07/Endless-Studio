using Studio.EntityFramework;
using System;
using System.Data.Entity;
using System.Linq;
using System.Windows.Forms;


namespace Studio
{
	public partial class MainForm : Form
	{
		EntityContext context;


		public MainForm()
		{
			InitializeComponent();
		}


		private void OnLoad(object sender, EventArgs e)
		{
			context = new EntityContext();
			Database.SetInitializer<EntityContext>(new EntityInitializer());
			context.ClearTables();
			context.SaveChanges();
			context.RuntimeModules.Load();
			this.runtimeModuleBindingSource.DataSource = context.RuntimeModules.Local.ToBindingList();
		}


		private void OnFormClosing(object sender, FormClosingEventArgs e)
		{
			this.context.Dispose();
		}



		private void runtimeModuleBindingNavigatorSaveItem_Click(object sender, EventArgs e)
		{
			this.Validate();

			// Currently, the Entity Framework doesn’t mark the entities 
			// that are removed from a navigation property (in our example the Products)
			// as deleted in the context. 
			// The following code uses LINQ to Objects against the Local collection 
			// to find all products and marks any that do not have
			// a Category reference as deleted. 
			// The ToList call is required because otherwise 
			// the collection will be modified 
			// by the Remove call while it is being enumerated. 
			// In most other situations you can do LINQ to Objects directly 
			// against the Local property without using ToList first.
			foreach (var plugin in context.RuntimePlugins.Local.ToList())
			{
				if (plugin.RuntimeModule == null)
				{
					context.RuntimePlugins.Remove(plugin);
				}
			}

			// Save the changes to the database.
			this.context.SaveChanges();

			// Refresh the controls to show the values         
			// that were generated by the database.
			this.runtimeModuleDataGridView.Refresh();
			this.pluginsDataGridView.Refresh();
		}


	}
}
